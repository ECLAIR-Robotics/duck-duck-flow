# 9-29-2025 Notes

Who was here? Isabella, Robert, Shalini 

Today we tested the connected the waterproof ultrasonic sensor to the ESP8266 microcontroller!

## Setup

[YouTube video walkthrough](https://www.youtube.com/watch?v=YN522_npNqs&list=PL4pptAPY2kIckUNYqpLpKE5qQISi1KvfS&index=1) if you prefer

1. Install Arduino IDE
2. Install esp8266 drivers. In Arduino IDE, click *file*>*preferences*>*additional boards manager URL*. Then, paste [THIS LINK](https://arduino.esp8266.com/stable/package_esp8266com_index.json) or (https://arduino.esp8266.com/stable/package_esp8266com_index.json) into the box provided. For reference, we found this link on [this github page](https://github.com/esp8266/arduino/
) which [this youtube video](https://www.youtube.com/watch?v=YN522_npNqs&list=PL4pptAPY2kIckUNYqpLpKE5qQISi1KvfS&index=1) recommened.
3. Switch to the right board. Click *tools*>*board*>*ESP8266*>*NodeMCU 1.0 (ESP-12E Module)* 
4. Create a new file and paste the code below in.
5. Upload the program (if not already uploaded). At the top left-hand corner, click the circled right arrow button.
6. Open the Serial Monitor to see output print statements. At the top right-hand corner, click the circled magnifying glass with elipses (...) button.

## Wiring the ultrasonic sensor

The waterproof ultrasonic sensor [pdf manual link](https://mm.digikey.com/Volume0/opasdata/d220001/medias/docus/201/SEN0313_Web.pdf) 

### Pins

According to the manual, the pins are as follows:

| Label | Name | Description                                      |
|-------|------|--------------------------------------------------|
| 1     | VCC  | Power Input                                      |
| 2     | GND  | Ground                                           |
| 3     | RX   | Processed Value/Real-time Value Output Selection |
| 4     | TX   | UART Output                                      |

After connecting the provided extender, VCC is red the red wire, GND is black, **RX is blue** and **TX is green**.

### Code 

The manual also provides sample code. Since we have an **ESP8266**, we needed to change some lines.

#### Pin setup
Create virtual ports on D5 and D6, which, according to AI, "Pins 10 and 9 used in the original code for SoftwareSerial are not available on ESP8266 boards like NodeMCU" (We have a NodeMCU apparently).

```ino
SoftwareSerial mySerial(D5, D6); // green TX, blue RX
```
Order is VERY IMPORTANT here. We wired the **green wire TX into D5** and the **blue wire RX into D6** because the other way wouldn't produce output, contrary to the provided comment.

#### Baud rate matching
Then, in `setup()`, change mySerial.begin to 9600 to match the ESP8266's baud rate to make sure that data is interpreted correctly.
```ino
mySerial.begin(9600);   // match ESP8266's baud rate
```

## Final modified code
That actually ran when compiled on Isabella's computer

```ino
/*
  *@File  : DFRobot_Distance_A01.ino  
  *@Brief : This example use A01NYUB ultrasonic sensor to measure distance
  *         With initialization completed, We can get distance value  
  *@Copyright [DFRobot](http://www.dfrobot.com),2016          
  *           GUN Lesser General Pulic License
  *@version V1.0            
  *@data  2019‐8‐28
*/
#include <SoftwareSerial.h>
SoftwareSerial mySerial(D5, D6); // TX green d5, RX blue d6 // according to AI, these are good chioces for pins for NodeMCU
// we need software serial 
unsigned char data[4]={};
float distance;
void setup()
{
  mySerial.begin(9600);   // match ESP8266's baud rate
  Serial.begin(9600); // match ESP8266's baud rate
}

void loop()
{
  // Serial.print("checkpoint 1");
    do{
     for(int i=0;i<4;i++)
     {
       data[i]=mySerial.read();
     }
  }while(mySerial.read()==0xff);
  // Serial.printf("checkpoint 2 data= %d|%d|%d|%d|\n", data[0], data[1], data[2], data[3]);
  // Serial.printf("checkpoint 2 data = %02X|%02X|%02X|%02X|\n", data[0], data[1], data[2], data[3]);
  mySerial.flush();
  if(data[0]==0xff)
    {
      int sum;
      sum=(data[0]+data[1]+data[2])&0x00FF;
      if(sum==data[3])
      {
        distance=(data[1]<<8)+data[2];
        if(distance>280)
          {
           Serial.print("distance=");
           Serial.print(distance/10);
           Serial.println("cm");
          }else  
              {
                Serial.println("Below the lower limit");         
              }
      }else Serial.println("ERROR: checksum failed");
     }
     delay(150);
}
```

## Next time

Attempt to connect the other temp sensor